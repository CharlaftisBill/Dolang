<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Rust AST Flowchart</title>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script src="https://dagrejs.github.io/project/dagre-d3/latest/dagre-d3.min.js"></script>

    <style>
        body { margin: 0; background-color: #1e1e1e; color: #d4d4d4; font-family: 'Consolas', monospace; overflow: hidden; }
        #controls { position: absolute; top: 10px; left: 10px; background: #252526; padding: 10px; border: 1px solid #333; border-radius: 4px; z-index: 100; }
        input { background: #3c3c3c; color: white; border: 1px solid #555; padding: 5px; }
        svg { width: 100vw; height: 100vh; }

        /* Node Styling */
        .node rect { stroke: #d4d4d4; fill: #2d2d2d; stroke-width: 1.5px; }
        .node text { fill: #d4d4d4; font-size: 12px; }

        /* Specific Node Colors */
        g.type-VAR > rect { stroke: #61afef; fill: #1a2430; }
        g.type-IDENTIFIER > rect { stroke: #56b6c2; fill: #1b2729; }
        g.type-CALL > rect { stroke: #e5c07b; fill: #2c2820; }
        g.type-IF > rect { stroke: #d19a66; fill: #2b221a; }
        g.type-FUNCSIGNATURE > rect { stroke: #c678dd; fill: #251e29; }
        g.type-SUCCESS > rect { stroke: #98c379; fill: #1e291b; }
        g.type-FAILURE > rect { stroke: #e06c75; fill: #2a1b1c; }
        g.type-BLOCK > rect { stroke: #abb2bf; stroke-dasharray: 5, 5; fill: #232323; }

        /* Edge Styling */
        .edgePath path { stroke: #666; fill: none; stroke-width: 1.5px; }
        .edgeLabel text { fill: #999; font-size: 10px; }
    </style>
</head>

<body>
    <div id="controls">
        <h3>AST Flowchart</h3>
        <input type="file" id="fileInput" accept=".json">
        <div id="status" style="margin-top:5px; font-size: 0.8em; color: #888;">Load your JSON</div>
    </div>
    <svg><g /></svg>

    <script>
        const g = new dagreD3.graphlib.Graph().setGraph({ rankdir: "TB", nodesep: 50, ranksep: 70 });

        document.getElementById('fileInput').addEventListener('change', function (event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => buildGraph(JSON.parse(e.target.result));
            reader.readAsText(file);
        });

        function buildGraph(data) {
            const nodes = data.nodes;
            const spans = data.spans || [];
            g.nodes().forEach(v => g.removeNode(v));

            const getLabel = (n, idx) => {
                let title = n.kind;
                let subtitle = "";
                const d = n.data;

                if (n.kind === "VAR") {
                    title = d.name;
                    // Try to resolve type name if 'kind' is an index
                    const typeNode = nodes[d.kind];
                    subtitle = typeNode ? `Type: ${typeNode.data}` : "Variable";
                } else if (n.kind === "IDENTIFIER" || n.kind === "I32" || n.kind === "STR") {
                    title = String(d);
                    subtitle = n.kind;
                } else if (n.kind === "SUCCESS") {
                    title = "RETURN";
                    subtitle = "Success";
                } else if (n.kind === "FAILURE") {
                    title = "FAIL";
                    subtitle = d.reason || "Error";
                } else if (n.kind === "FUNCSIGNATURE") {
                    title = "SIGNATURE";
                    subtitle = `(${d.params.length} params)`;
                }

                const span = spans[idx] ? `<br/><span style="color:#555;font-size:9px;">L${spans[idx].line}:${spans[idx].start}</span>` : "";
                
                return `<div style="text-align: center; padding: 8px;">
                    <b style="font-size:1.1em;">${title}</b><br/>
                    <span style="opacity:0.6; font-size:0.9em;">${subtitle}</span>
                    ${span}
                </div>`;
            };

            // 1. Add Nodes
            nodes.forEach((n, i) => {
                g.setNode(i.toString(), {
                    labelType: "html",
                    label: getLabel(n, i),
                    class: "type-" + n.kind,
                    rx: 5, ry: 5
                });
            });

            // 2. Add Edges
            nodes.forEach((n, i) => {
                const d = n.data;
                if (!d) return;

                const add = (target, label) => {
                    if (target !== null && target !== undefined) 
                        g.setEdge(i.toString(), target.toString(), { label: label, curve: d3.curveBasis });
                };

                if (n.kind === "VAR") {
                    add(d.kind, "type");
                    add(d.value, "init");
                } else if (n.kind === "BLOCK") {
                    d.forEach((id, idx) => add(id, `step ${idx}`));
                } else if (n.kind === "CALL") {
                    add(d.func, "fn");
                    d.args.forEach((id, idx) => add(id, `arg ${idx}`));
                } else if (n.kind === "IF") {
                    add(d.condition, "cond");
                    add(d.body, "then");
                } else if (n.kind === "BINARY") {
                    const op = Object.keys(d)[0];
                    add(d[op][0], "L");
                    add(d[op][1], "R");
                } else if (n.kind === "FUNCSIGNATURE") {
                    d.params.forEach(id => add(id, "param"));
                    d.returns.forEach(id => add(id, "ret"));
                } else if (n.kind === "SUCCESS" || n.kind === "FAILURE") {
                    if (d.return_values) d.return_values.forEach(id => add(id, "val"));
                }
            });

            render();
        }

        const svg = d3.select("svg");
        const inner = svg.select("g");
        const renderEngine = new dagreD3.render();
        const zoom = d3.zoom().on("zoom", () => inner.attr("transform", d3.event.transform));
        svg.call(zoom);

        function render() {
            renderEngine(inner, g);
            const initialScale = 0.8;
            const xCenter = (svg.node().getBoundingClientRect().width - g.graph().width * initialScale) / 2;
            svg.call(zoom.transform, d3.zoomIdentity.translate(xCenter, 40).scale(initialScale));
        }
    </script>
</body>
</html>