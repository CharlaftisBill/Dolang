<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Rust AST Flowchart</title>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script src="https://dagrejs.github.io/project/dagre-d3/latest/dagre-d3.min.js"></script>

    <style>
        :root {
            /* Solarized / VSCode Dark inspired palette */
            --color-decl: #61afef;
            /* Blue */
            --bg-decl: #1a2430;
            --color-assign: #e5c07b;
            /* Gold/Yellow */
            --bg-assign: #2c2820;
            --color-id: #56b6c2;
            /* Cyan */
            --bg-id: #1b2729;
            --color-val: #98c379;
            /* Green */
            --bg-val: #1e291b;
            --color-op: #c678dd;
            /* Purple */
            --bg-op: #2a202e;
            --color-block: #abb2bf;
            /* Gray */
            --bg-block: #232323;
            --color-fail: #e06c75;
            /* Red */
            --bg-fail: #2a1b1c;
        }

        body {
            margin: 0;
            background-color: #1e1e1e;
            color: #d4d4d4;
            font-family: 'Consolas', monospace;
            overflow: hidden;
        }

        #controls,
        #legend,
        #zoom-controls {
            position: absolute;
            background: #252526;
            padding: 12px;
            border: 1px solid #333;
            border-radius: 4px;
            z-index: 100;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
        }

        #controls {
            top: 10px;
            left: 10px;
            width: 220px;
        }

        #legend {
            top: 10px;
            right: 10px;
            font-size: 0.85em;
            width: 180px;
        }

        #zoom-controls {
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
        }

        h3 {
            margin: 0 0 10px 0;
            font-size: 1.1em;
            border-bottom: 1px solid #444;
            padding-bottom: 5px;
        }

        button {
            background: #3c3c3c;
            color: white;
            border: 1px solid #555;
            padding: 6px 12px;
            cursor: pointer;
            border-radius: 3px;
            font-family: inherit;
            transition: background 0.2s;
        }

        button:hover {
            background: #505050;
        }

        input[type="file"] {
            background: #3c3c3c;
            color: white;
            border: 1px solid #555;
            padding: 5px;
            width: 100%;
            box-sizing: border-box;
            font-size: 0.8em;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 6px;
        }

        .swatch {
            width: 14px;
            height: 14px;
            margin-right: 10px;
            border-radius: 2px;
            border: 1.5px solid white;
        }

        /* --- Node Styling --- */
        .node rect {
            stroke-width: 1.5px;
        }

        g.type-DECLARATION>rect {
            stroke: var(--color-decl);
            fill: var(--bg-decl);
            stroke-width: 2px;
        }

        g.type-ASSIGNMENT>rect {
            stroke: var(--color-assign);
            fill: var(--bg-assign);
            stroke-width: 2px;
        }

        g.type-VAR>rect {
            stroke: var(--color-decl);
            fill: var(--bg-decl);
        }

        g.type-IDENTIFIER>rect {
            stroke: var(--color-id);
            fill: var(--bg-id);
        }

        g.type-I32>rect,
        g.type-F32>rect,
        g.type-STR>rect {
            stroke: var(--color-val);
            fill: var(--bg-val);
        }

        g.type-CALL>rect {
            stroke: var(--color-assign);
            fill: var(--bg-assign);
            stroke-width: 2.5px;
        }

        g.type-BINARY>rect {
            stroke: var(--color-op);
            fill: var(--bg-op);
        }

        g.type-BLOCK>rect {
            stroke: var(--color-block);
            fill: var(--bg-block);
            stroke-dasharray: 4, 4;
        }

        g.type-SUCCESS>rect {
            stroke: var(--color-val);
            fill: var(--bg-val);
        }

        g.type-FAILURE>rect {
            stroke: var(--color-fail);
            fill: var(--bg-fail);
        }

        svg {
            width: 100vw;
            height: 100vh;
            cursor: grab;
        }

        svg:active {
            cursor: grabbing;
        }

        .node text {
            fill: #d4d4d4;
            font-size: 12px;
        }

        .edgePath path {
            stroke: #666;
            fill: none;
            stroke-width: 1.5px;
        }

        .edgeLabel text {
            fill: #888;
            font-size: 10px;
        }
    </style>
</head>

<body>

    <div id="controls">
        <h3>AST Controls</h3>
        <input type="file" id="fileInput" accept=".json">
        <div id="status" style="margin-top:5px; font-size: 0.75em; color: #888;">Select ast.json</div>
    </div>

    <div id="legend">
        <h3>Legend</h3>
        <div class="legend-item">
            <div class="swatch" style="border-color: var(--color-decl); background: var(--bg-decl);"></div> Declarations
        </div>
        <div class="legend-item">
            <div class="swatch" style="border-color: var(--color-assign); background: var(--bg-assign);"></div>
            Assignments
        </div>
        <div class="legend-item">
            <div class="swatch" style="border-color: var(--color-val); background: var(--bg-val);"></div> Literals (i32,
            str)
        </div>
        <div class="legend-item">
            <div class="swatch" style="border-color: var(--color-id); background: var(--bg-id);"></div> Identifiers
        </div>
        <div class="legend-item">
            <div class="swatch" style="border-color: var(--color-op); background: var(--bg-op);"></div> Operations
        </div>
        <div class="legend-item">
            <div class="swatch"
                style="border-color: var(--color-block); background: var(--bg-block); border-style: dashed;"></div> Code
            Blocks
        </div>
    </div>

    <div id="zoom-controls">
        <button id="zoom-in" title="Zoom In">+</button>
        <button id="zoom-out" title="Zoom Out">-</button>
        <button id="zoom-reset" title="Zoom 1:1">0</button>
        <button id="move-center" title="Fit to Screen">Center</button>
    </div>

    <svg>
        <g />
    </svg>

    <script>
        const svg = d3.select("svg");
        const inner = svg.select("g");
        const renderEngine = new dagreD3.render();
        let g = new dagreD3.graphlib.Graph();

        // Zoom setup
        const zoom = d3.zoom().on("zoom", () => {
            inner.attr("transform", d3.event.transform);
        });
        svg.call(zoom);

        // Buttons
        document.getElementById('zoom-in').onclick = () => svg.transition().duration(300).call(zoom.scaleBy, 1.2);
        document.getElementById('zoom-out').onclick = () => svg.transition().duration(300).call(zoom.scaleBy, 0.8);
        document.getElementById('zoom-reset').onclick = () => svg.transition().duration(300).call(zoom.transform, d3.zoomIdentity);
        document.getElementById('move-center').onclick = () => centerGraph(true);

        function centerGraph(animate = true) {
            if (!g.nodeCount()) return;
            const graphWidth = g.graph().width;
            const graphHeight = g.graph().height;
            const svgWidth = svg.node().getBoundingClientRect().width;
            const svgHeight = svg.node().getBoundingClientRect().height;

            // Calculate scale to fit (with 50px padding)
            const scale = Math.min(1, Math.min(svgWidth / (graphWidth + 50), svgHeight / (graphHeight + 50)));
            const x = (svgWidth - graphWidth * scale) / 2;
            const y = (svgHeight - graphHeight * scale) / 2;
            const transform = d3.zoomIdentity.translate(x, y).scale(scale);

            if (animate) svg.transition().duration(500).call(zoom.transform, transform);
            else svg.call(zoom.transform, transform);
        }

        document.getElementById('fileInput').addEventListener('change', function (event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    buildGraph(JSON.parse(e.target.result));
                    document.getElementById('status').innerText = "Loaded: " + file.name;
                } catch (err) { alert("JSON Error: " + err.message); }
            };
            reader.readAsText(file);
        });

        function buildGraph(flatData) {
            const nodes = flatData.nodes;
            const spans = flatData.spans || [];

            // 1. CLEAR & RESET
            svg.call(zoom.transform, d3.zoomIdentity); // Reset zoom to 1:1 before calculating
            inner.selectAll("*").remove(); // Clear DOM

            // 2. INIT GRAPH
            g = new dagreD3.graphlib.Graph()
                .setGraph({ rankdir: "TB", nodesep: 40, ranksep: 60, marginx: 20, marginy: 20 })
                .setDefaultEdgeLabel(() => ({}));

            // 3. DEFINE LABELS
            const getLabel = (n, idx) => {
                let title = n.kind;
                let subtitle = "";
                let meta = "";
                const d = n.data;

                if (n.kind === "DECLARATION") {
                    title = "DECLARATION";

                    // Show ONLY the Name in the subtitle, not the type
                    subtitle = `<span style="font-size:1.1em; color:#fff">${d.name}</span>`;

                    if (d.constant) meta += "CONST ";
                    if (d.public) meta += "PUB ";
                }
                else if (n.kind === "ASSIGNMENT") {
                    title = "ASSIGN";
                    subtitle = "=";
                }
                else if (n.kind === "VAR") {
                    title = d.name;
                    subtitle = "Variable";
                }
                else if (["IDENTIFIER", "I32", "F32", "STR", "BOOL", "CHAR"].includes(n.kind)) {
                    title = String(d);
                    subtitle = n.kind;
                }
                else if (n.kind === "BINARY") {
                    title = Object.keys(d)[0] || n.kind;
                    subtitle = "Op";
                }
                else if (n.kind === "BLOCK") {
                    title = "BLOCK";
                    subtitle = Array.isArray(d) ? `${d.length} stmts` : "";
                }
                else if (n.kind === "FUNCSIGNATURE") {
                    title = "SIGNATURE";
                    subtitle = `Params: ${d.params.length}`;
                }

                let spanHtml = spans[idx] ? `<br/><span style="color:#666; font-size:9px;">L${spans[idx].line}</span>` : "";

                return `<div style="text-align: center; padding: 10px; min-width: 90px;">
                        <span style="color:#ff79c6; font-size:0.7em;">${meta}</span><br/>
                        <span style="font-weight:bold; font-size:1.1em;">${title}</span><br/>
                        <span style="font-size:0.8em; opacity:0.7">${subtitle}</span>
                        ${spanHtml}
                    </div>`;
            };

            // 4. ADD NODES
            nodes.forEach((n, index) => {
                g.setNode(index.toString(), {
                    labelType: "html",
                    label: getLabel(n, index),
                    rx: 5, ry: 5,
                    class: "type-" + n.kind
                });
            });

            // 5. ADD EDGES
            nodes.forEach((n, parentId) => {
                const d = n.data;
                if (!d && d !== 0) return;

                const addEdge = (childId, label = "") => {
                    if (childId !== null && childId !== undefined) {
                        g.setEdge(parentId.toString(), childId.toString(), {
                            label: label,
                            curve: d3.curveBasis
                        });
                    }
                };

                if (n.kind === "DECLARATION") {
                    addEdge(d.kind, "type");
                    if (d.value !== undefined && d.value !== null) addEdge(d.value, "init");
                }
                else if (n.kind === "ASSIGNMENT") {
                    addEdge(d.declaration, "target");
                    addEdge(d.value, "value");
                }
                else if (n.kind === "VAR") {
                    addEdge(d.kind, "type");
                    if (d.value !== null) addEdge(d.value, "init");
                }
                else if (n.kind === "BLOCK") {
                    if (Array.isArray(d)) d.forEach((stmt, i) => addEdge(stmt, String(i + 1)));
                }
                else if (n.kind === "CALL") {
                    addEdge(d.func, "fn");
                    if (d.args) d.args.forEach((arg, i) => addEdge(arg, `arg${i}`));
                }
                else if (n.kind === "BINARY") {
                    const op = Object.keys(d)[0];
                    if (Array.isArray(d[op])) {
                        addEdge(d[op][0], "L");
                        addEdge(d[op][1], "R");
                    }
                }
                else if (n.kind === "IF") {
                    addEdge(d.condition, "cond");
                    addEdge(d.body, "then");
                }
                else if (n.kind === "FUNCSIGNATURE") {
                    d.params.forEach(p => addEdge(p, "param"));
                    if (d.returns) d.returns.forEach(r => addEdge(r, "ret"));
                }
                else if (n.kind === "SUCCESS" || n.kind === "FAILURE") {
                    if (d.return_values) d.return_values.forEach(v => addEdge(v, "val"));
                }
            });

            // 6. RENDER
            renderEngine(inner, g);
            centerGraph(false);
        }

        window.onresize = () => centerGraph(false);
    </script>
</body>

</html>