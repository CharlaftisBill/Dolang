<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Rust AST Flowchart</title>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script src="https://dagrejs.github.io/project/dagre-d3/latest/dagre-d3.min.js"></script>

    <style>
        :root {
            /* Solarized / VSCode Dark inspired palette */
            --color-decl: #61afef;
            /* Blue */
            --bg-decl: #1a2430;
            --color-assign: #e5c07b;
            /* Gold/Yellow */
            --bg-assign: #2c2820;
            --color-id: #56b6c2;
            /* Cyan */
            --bg-id: #1b2729;
            --color-val: #98c379;
            /* Green */
            --bg-val: #1e291b;
            --color-op: #c678dd;
            /* Purple */
            --bg-op: #2a202e;
            --color-array: #c586c0;
            /* Magenta/Pink */
            --bg-array: #2d202a;
            --color-flow: #d19a66;
            /* Orange */
            --bg-flow: #2b221a;
            --color-block: #abb2bf;
            /* Gray */
            --bg-block: #232323;
            --color-fail: #e06c75;
            /* Red */
            --bg-fail: #2a1b1c;
        }

        body {
            margin: 0;
            background-color: #1e1e1e;
            color: #d4d4d4;
            font-family: 'Consolas', monospace;
            overflow: hidden;
        }

        #controls,
        #legend,
        #zoom-controls {
            position: absolute;
            background: #252526;
            padding: 12px;
            border: 1px solid #333;
            border-radius: 4px;
            z-index: 100;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
        }

        #controls {
            top: 10px;
            left: 10px;
            width: 220px;
        }

        #legend {
            top: 10px;
            right: 10px;
            font-size: 0.85em;
            width: 180px;
        }

        #zoom-controls {
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
        }

        h3 {
            margin: 0 0 10px 0;
            font-size: 1.1em;
            border-bottom: 1px solid #444;
            padding-bottom: 5px;
        }

        button {
            background: #3c3c3c;
            color: white;
            border: 1px solid #555;
            padding: 6px 12px;
            cursor: pointer;
            border-radius: 3px;
            font-family: inherit;
            transition: background 0.2s;
        }

        button:hover {
            background: #505050;
        }

        input[type="file"] {
            background: #3c3c3c;
            color: white;
            border: 1px solid #555;
            padding: 5px;
            width: 100%;
            box-sizing: border-box;
            font-size: 0.8em;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 6px;
        }

        .swatch {
            width: 14px;
            height: 14px;
            margin-right: 10px;
            border-radius: 2px;
            border: 1.5px solid white;
        }

        /* --- Node Styling --- */
        .node rect {
            stroke-width: 1.5px;
        }

        g.type-DECLARATION>rect {
            stroke: var(--color-decl);
            fill: var(--bg-decl);
            stroke-width: 2px;
        }

        g.type-ASSIGNMENT>rect {
            stroke: var(--color-assign);
            fill: var(--bg-assign);
            stroke-width: 2px;
        }

        g.type-IDENTIFIER>rect {
            stroke: var(--color-id);
            fill: var(--bg-id);
        }

        /* Value Types */
        g.type-I32>rect,
        g.type-F32>rect,
        g.type-STR>rect,
        g.type-BOOL>rect,
        g.type-CHAR>rect {
            stroke: var(--color-val);
            fill: var(--bg-val);
        }

        g.type-ARRAYKIND>rect,
        g.type-ARRAYVALUE>rect {
            stroke: var(--color-array);
            fill: var(--bg-array);
        }

        g.type-CALL>rect {
            stroke: var(--color-assign);
            fill: var(--bg-assign);
            stroke-width: 2.5px;
        }

        g.type-BINARY>rect,
        g.type-UNARY>rect {
            stroke: var(--color-op);
            fill: var(--bg-op);
        }

        /* Control Flow: IF, ELSE, WHILE, FOR, MATCH, CASE, CATCH */
        g.type-IF>rect,
        g.type-ELSE>rect,
        g.type-WHILE>rect,
        g.type-FOR>rect,
        g.type-MATCH>rect,
        g.type-CASE>rect,
        g.type-CATCH>rect {
            stroke: var(--color-flow);
            fill: var(--bg-flow);
        }

        g.type-BLOCK>rect {
            stroke: var(--color-block);
            fill: var(--bg-block);
            stroke-dasharray: 4, 4;
        }

        g.type-SUCCESS>rect {
            stroke: var(--color-val);
            fill: var(--bg-val);
        }

        g.type-FAILURE>rect {
            stroke: var(--color-fail);
            fill: var(--bg-fail);
        }

        svg {
            width: 100vw;
            height: 100vh;
            cursor: grab;
        }

        svg:active {
            cursor: grabbing;
        }

        .node text {
            fill: #d4d4d4;
            font-size: 12px;
        }

        .edgePath path {
            stroke: #666;
            fill: none;
            stroke-width: 1.5px;
        }

        .edgeLabel text {
            fill: #888;
            font-size: 10px;
        }
    </style>
</head>

<body>

    <div id="controls">
        <h3>AST Controls</h3>
        <input type="file" id="fileInput" accept=".json">
        <div id="status" style="margin-top:5px; font-size: 0.75em; color: #888;">Select ast.json</div>
    </div>

    <div id="legend">
        <h3>Legend</h3>
        <div class="legend-item">
            <div class="swatch" style="border-color: var(--color-decl); background: var(--bg-decl);"></div> Declarations
        </div>
        <div class="legend-item">
            <div class="swatch" style="border-color: var(--color-assign); background: var(--bg-assign);"></div>
            Assignments
        </div>
        <div class="legend-item">
            <div class="swatch" style="border-color: var(--color-flow); background: var(--bg-flow);"></div> Control Flow
        </div>
        <div class="legend-item">
            <div class="swatch" style="border-color: var(--color-array); background: var(--bg-array);"></div> Arrays
        </div>
        <div class="legend-item">
            <div class="swatch" style="border-color: var(--color-val); background: var(--bg-val);"></div> Values /
            Literals
        </div>
        <div class="legend-item">
            <div class="swatch" style="border-color: var(--color-id); background: var(--bg-id);"></div> Identifiers
        </div>
        <div class="legend-item">
            <div class="swatch" style="border-color: var(--color-op); background: var(--bg-op);"></div> Operations
        </div>
        <div class="legend-item">
            <div class="swatch"
                style="border-color: var(--color-block); background: var(--bg-block); border-style: dashed;"></div> Code
            Blocks
        </div>
    </div>

    <div id="zoom-controls">
        <button id="zoom-in" title="Zoom In">+</button>
        <button id="zoom-out" title="Zoom Out">-</button>
        <button id="zoom-reset" title="Zoom 1:1">0</button>
        <button id="move-center" title="Fit to Screen">Center</button>
    </div>

    <svg>
        <g />
    </svg>

    <script>
        const svg = d3.select("svg");
        const inner = svg.select("g");
        const renderEngine = new dagreD3.render();
        let g = new dagreD3.graphlib.Graph();

        // --- Zoom Setup ---
        const zoom = d3.zoom().on("zoom", () => {
            inner.attr("transform", d3.event.transform);
        });
        svg.call(zoom);

        // --- Navigation Buttons ---
        document.getElementById('zoom-in').onclick = () => svg.transition().duration(300).call(zoom.scaleBy, 1.2);
        document.getElementById('zoom-out').onclick = () => svg.transition().duration(300).call(zoom.scaleBy, 0.8);
        document.getElementById('zoom-reset').onclick = () => svg.transition().duration(300).call(zoom.transform, d3.zoomIdentity);
        document.getElementById('move-center').onclick = () => centerGraph(true);

        function centerGraph(animate = true) {
            if (!g.nodeCount()) return;
            const graphWidth = g.graph().width;
            const graphHeight = g.graph().height;
            const svgWidth = svg.node().getBoundingClientRect().width;
            const svgHeight = svg.node().getBoundingClientRect().height;
            const scale = Math.min(1, Math.min(svgWidth / (graphWidth + 50), svgHeight / (graphHeight + 50)));
            const x = (svgWidth - graphWidth * scale) / 2;
            const y = (svgHeight - graphHeight * scale) / 2;
            const transform = d3.zoomIdentity.translate(x, y).scale(scale);
            if (animate) svg.transition().duration(500).call(zoom.transform, transform);
            else svg.call(zoom.transform, transform);
        }

        // --- File Upload ---
        document.getElementById('fileInput').addEventListener('change', function (event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    buildGraph(JSON.parse(e.target.result));
                    document.getElementById('status').innerText = "Loaded: " + file.name;
                } catch (err) { alert("JSON Error: " + err.message); }
            };
            reader.readAsText(file);
        });

        // --- Graph Builder ---
        function buildGraph(flatData) {
            const nodes = flatData.nodes;
            const spans = flatData.spans || [];

            // Hard Reset for layout consistency
            svg.call(zoom.transform, d3.zoomIdentity);
            inner.selectAll("*").remove();

            g = new dagreD3.graphlib.Graph()
                .setGraph({ rankdir: "TB", nodesep: 40, ranksep: 60, marginx: 20, marginy: 20 })
                .setDefaultEdgeLabel(() => ({}));

            const getLabel = (n, idx) => {
                let title = n.kind;
                let subtitle = "";
                let meta = "";
                const d = n.data;

                if (n.kind === "DECLARATION") {
                    title = "DECLARATION";
                    subtitle = `<span style="font-size:1.1em; color:#fff">${d.name}</span>`;

                    const typeNode = nodes[d.kind];
                    if (typeNode && typeNode.kind === "ARRAYKIND") {
                        const innerType = nodes[typeNode.data.kind];
                        const innerName = innerType ? innerType.data : "?";
                        subtitle += `<br/><span style="font-size:0.8em; color:#aaa">[${innerName}; ${typeNode.data.size}]</span>`;
                    }
                    if (d.constant) meta += "CONST ";
                    if (d.public) meta += "PUB ";
                }
                else if (n.kind === "ASSIGNMENT") {
                    title = "ASSIGN";
                    if (d.operator !== undefined && nodes[d.operator]) {
                        subtitle = `<span style="font-size:1.5em; font-weight:bold; color:#fff">${nodes[d.operator].data}</span>`;
                    } else {
                        subtitle = "=";
                    }
                }
                else if (n.kind === "ARRAYKIND") {
                    title = "ARRAY TYPE";
                    subtitle = `Size: ${d.size}`;
                }
                else if (n.kind === "ARRAYVALUE") {
                    title = "ARRAY LITERAL";
                    subtitle = `Len: ${Array.isArray(d.value) ? d.value.length : 0}`;
                }
                else if (n.kind === "VAR") {
                    title = d.name;
                    subtitle = "Variable";
                }
                else if (["IDENTIFIER", "I32", "F32", "STR", "BOOL", "CHAR"].includes(n.kind)) {
                    title = String(d);
                    subtitle = n.kind;
                }
                else if (n.kind === "BINARY" || n.kind === "UNARY") {
                    title = Object.keys(d)[0] || n.kind;
                    subtitle = n.kind === "BINARY" ? "Binary" : "Unary";
                }
                else if (n.kind === "BLOCK") {
                    title = "BLOCK";
                    subtitle = Array.isArray(d) ? `${d.length} stmts` : "";
                }
                else if (n.kind === "FUNCSIGNATURE") {
                    title = "SIGNATURE";
                    subtitle = `Params: ${d.params.length}`;
                }
                // --- Control Flow ---
                else if (n.kind === "IF") { title = "IF"; subtitle = "Control Flow"; }
                else if (n.kind === "ELSE") {
                    title = (d.condition !== null) ? "ELSE IF" : "ELSE";
                    subtitle = "Control Flow";
                }
                else if (n.kind === "WHILE") { title = "WHILE"; subtitle = "Loop"; }
                else if (n.kind === "FOR") {
                    title = "FOR";
                    const idxNode = nodes[d.index];
                    const idxName = idxNode ? idxNode.data : "?";
                    subtitle = `Iter: <span style="color:#fff">${idxName}</span>`;
                }
                else if (n.kind === "MATCH") { title = "MATCH"; subtitle = "Control Flow"; }

                // --- NEW: CASE and CATCH ---
                else if (n.kind === "CASE") {
                    title = "CASE";
                    subtitle = "Pattern";
                }
                else if (n.kind === "CATCH") {
                    title = "CATCH";
                    subtitle = "Error Handling";
                }

                else if (n.kind === "SUCCESS") {
                    title = "SUCCESS";
                    subtitle = "Result";
                }
                else if (n.kind === "FAILURE") {
                    title = "FAILURE";
                    subtitle = d.reason ? `<span style="color:#e06c75; font-weight:bold; font-style:italic;">"${d.reason}"</span>` : "Error";
                }

                let spanHtml = spans[idx] ? `<br/><span style="color:#666; font-size:9px;">L${spans[idx].line}</span>` : "";

                return `<div style="text-align: center; padding: 10px; min-width: 90px;">
                        <span style="color:#ff79c6; font-size:0.7em;">${meta}</span><br/>
                        <span style="font-weight:bold; font-size:1.1em;">${title}</span><br/>
                        <span style="font-size:0.8em; opacity:0.7">${subtitle}</span>
                        ${spanHtml}
                    </div>`;
            };

            // Add Nodes
            nodes.forEach((n, index) => {
                g.setNode(index.toString(), {
                    labelType: "html",
                    label: getLabel(n, index),
                    rx: 5, ry: 5,
                    class: "type-" + n.kind
                });
            });

            // Add Edges
            nodes.forEach((n, parentId) => {
                const d = n.data;
                if (!d && d !== 0) return;

                const addEdge = (childId, label = "", opts = {}) => {
                    if (childId !== null && childId !== undefined) {
                        g.setEdge(parentId.toString(), childId.toString(), {
                            label: label,
                            curve: d3.curveBasis,
                            ...opts
                        });
                    }
                };

                if (n.kind === "DECLARATION") {
                    addEdge(d.kind, "type");
                    if (d.value !== undefined && d.value !== null) addEdge(d.value, "init");
                }
                else if (n.kind === "ASSIGNMENT") {
                    addEdge(d.declaration, "target", { constraint: false, style: "stroke-dasharray: 5, 5; stroke: #666;" });
                    addEdge(d.value, "value");
                    if (d.operator !== undefined) addEdge(d.operator, "op");
                }
                else if (n.kind === "ARRAYKIND") {
                    addEdge(d.kind, "elem type");
                }
                else if (n.kind === "ARRAYVALUE") {
                    addEdge(d.kind, "type");
                    if (Array.isArray(d.value)) d.value.forEach((val, i) => addEdge(val, `[${i}]`));
                }
                else if (n.kind === "VAR") {
                    addEdge(d.kind, "type");
                    if (d.value !== null) addEdge(d.value, "init");
                }
                else if (n.kind === "BLOCK") {
                    if (Array.isArray(d)) d.forEach((stmt, i) => addEdge(stmt, String(i + 1)));
                }
                else if (n.kind === "CALL") {
                    addEdge(d.func, "fn");
                    if (d.args) d.args.forEach((arg, i) => addEdge(arg, `arg${i}`));
                }
                else if (n.kind === "BINARY") {
                    const op = Object.keys(d)[0];
                    if (Array.isArray(d[op])) { addEdge(d[op][0], "L"); addEdge(d[op][1], "R"); }
                }
                else if (n.kind === "UNARY") {
                    const op = Object.keys(d)[0];
                    addEdge(d[op], "operand");
                }
                else if (n.kind === "IF") {
                    addEdge(d.condition, "cond");
                    addEdge(d.body, "then");
                }
                else if (n.kind === "ELSE") {
                    if (d.condition !== null) addEdge(d.condition, "cond");
                    addEdge(d.body, "body");
                }
                else if (n.kind === "WHILE") {
                    addEdge(d.condition, "cond");
                    addEdge(d.body, "do");
                }
                else if (n.kind === "FOR") {
                    addEdge(d.index, "iter");
                    if (d.value !== undefined && d.value !== null) addEdge(d.value, "val");
                    addEdge(d.range, "range");
                    addEdge(d.body, "do");
                }
                else if (n.kind === "MATCH") {
                    addEdge(d.expression, "on");
                    if (Array.isArray(d.body)) d.body.forEach(caseId => addEdge(caseId, "case"));
                }
                // --- NEW: CASE and CATCH Edges ---
                else if (n.kind === "CASE") {
                    if (Array.isArray(d.matching_values)) {
                        d.matching_values.forEach(val => addEdge(val, "pattern"));
                    }
                    addEdge(d.body, "do");
                }
                else if (n.kind === "CATCH") {
                    // Connect to list of cases
                    if (Array.isArray(d.body)) {
                        d.body.forEach(caseId => addEdge(caseId, "handle"));
                    }
                }

                else if (n.kind === "FUNCSIGNATURE") {
                    d.params.forEach(p => addEdge(p, "param"));
                    if (d.returns) d.returns.forEach(r => addEdge(r, "ret"));
                }
                else if (n.kind === "SUCCESS" || n.kind === "FAILURE") {
                    if (d.return_values) d.return_values.forEach(v => addEdge(v, "val"));
                }
            });

            renderEngine(inner, g);
            centerGraph(false);
        }

        window.onresize = () => centerGraph(false);
    </script>
</body>

</html>